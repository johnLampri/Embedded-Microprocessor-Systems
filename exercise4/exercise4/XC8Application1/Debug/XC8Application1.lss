
XC8Application1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000b0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00000366  000003da  2**0
                  ALLOC, LOAD, DATA
  2 .comment      0000002f  00000000  00000000  000003da  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000080  00000000  00000000  00000410  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000a84  00000000  00000000  00000490  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000643  00000000  00000000  00000f14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000644  00000000  00000000  00001557  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000194  00000000  00000000  00001b9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000207  00000000  00000000  00001d30  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000301  00000000  00000000  00001f37  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000050  00000000  00000000  00002238  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .text         00000004  00000356  00000356  000003ca  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002288  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000108  000000b4  000000b4  00000128  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text.InitialiseRT 00000010  0000033a  0000033a  000003ae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.EnableTxc 00000006  0000034a  0000034a  000003be  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.DisableTxc 00000006  00000350  00000350  000003c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.USART_UDRE 00000030  000002e8  000002e8  0000035c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.__vector_12 00000048  00000210  00000210  00000284  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.USART_RXC 00000022  00000318  00000318  0000038c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.__vector_11 00000048  00000258  00000258  000002cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .rodata       0000000c  00800060  0000035a  000003ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 22 .text.main    00000054  000001bc  000001bc  00000230  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.__vector_8 00000048  000002a0  000002a0  00000314  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .progmemx.data.data1 00000004  000000b0  000000b0  00000124  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
   8:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
   c:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  10:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  14:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  18:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  1c:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  20:	0c 94 50 01 	jmp	0x2a0	; 0x2a0 <__vector_8>
  24:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  28:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  2c:	0c 94 2c 01 	jmp	0x258	; 0x258 <__vector_11>
  30:	0c 94 08 01 	jmp	0x210	; 0x210 <__vector_12>
  34:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  38:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  3c:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  40:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  44:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  48:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  4c:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>
  50:	0c 94 ab 01 	jmp	0x356	; 0x356 <__bad_interrupt>

00000054 <.dinit>:
  54:	00 60       	ori	r16, 0x00	; 0
  56:	00 6c       	ori	r16, 0xC0	; 192
  58:	00 03       	mulsu	r16, r16
  5a:	5a 00       	.word	0x005a	; ????

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf e5       	ldi	r28, 0x5F	; 95
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61

00000068 <__do_copy_data>:
  68:	e4 e5       	ldi	r30, 0x54	; 84
  6a:	f0 e0       	ldi	r31, 0x00	; 0
  6c:	40 e0       	ldi	r20, 0x00	; 0
  6e:	17 c0       	rjmp	.+46     	; 0x9e <__do_clear_bss+0x8>
  70:	b5 91       	lpm	r27, Z+
  72:	a5 91       	lpm	r26, Z+
  74:	35 91       	lpm	r19, Z+
  76:	25 91       	lpm	r18, Z+
  78:	05 91       	lpm	r16, Z+
  7a:	07 fd       	sbrc	r16, 7
  7c:	0c c0       	rjmp	.+24     	; 0x96 <__do_clear_bss>
  7e:	95 91       	lpm	r25, Z+
  80:	85 91       	lpm	r24, Z+
  82:	ef 01       	movw	r28, r30
  84:	f9 2f       	mov	r31, r25
  86:	e8 2f       	mov	r30, r24
  88:	05 90       	lpm	r0, Z+
  8a:	0d 92       	st	X+, r0
  8c:	a2 17       	cp	r26, r18
  8e:	b3 07       	cpc	r27, r19
  90:	d9 f7       	brne	.-10     	; 0x88 <__do_copy_data+0x20>
  92:	fe 01       	movw	r30, r28
  94:	04 c0       	rjmp	.+8      	; 0x9e <__do_clear_bss+0x8>

00000096 <__do_clear_bss>:
  96:	1d 92       	st	X+, r1
  98:	a2 17       	cp	r26, r18
  9a:	b3 07       	cpc	r27, r19
  9c:	e1 f7       	brne	.-8      	; 0x96 <__do_clear_bss>
  9e:	eb 35       	cpi	r30, 0x5B	; 91
  a0:	f4 07       	cpc	r31, r20
  a2:	31 f7       	brne	.-52     	; 0x70 <__do_copy_data+0x8>
  a4:	0e 94 de 00 	call	0x1bc	; 0x1bc <main>
  a8:	0c 94 56 00 	jmp	0xac	; 0xac <_exit>

000000ac <_exit>:
  ac:	f8 94       	cli

000000ae <__stop_program>:
  ae:	ff cf       	rjmp	.-2      	; 0xae <__stop_program>

Disassembly of section .text:

00000356 <__bad_interrupt>:
 356:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text:

000000b4 <InitialiseMemory>:

  
	;Subroutine used for the initialisation of the Memory registers
	InitialiseMemory: 

	ldi	XL,CommandL	; initialize X pointer
  b4:	a0 e6       	ldi	r26, 0x60	; 96
	ldi	XH,CommandH	; to Command address
  b6:	b0 e0       	ldi	r27, 0x00	; 0
	ret;
  b8:	08 95       	ret

000000ba <InitialiseLED>:
;Subroutine used for the initialisation of the leds
	InitialiseLED:
    ldi r24, 0xFF;
  ba:	8f ef       	ldi	r24, 0xFF	; 255
    out DDRA, r24;
  bc:	8a bb       	out	0x1a, r24	; 26
	ldi r24, 0xFF;
  be:	8f ef       	ldi	r24, 0xFF	; 255
    out DDRC, r24;
  c0:	84 bb       	out	0x14, r24	; 20
	ret
  c2:	08 95       	ret

000000c4 <InitialiseTimer>:
	;Subroutine used for the initialisation of the timer1
	InitialiseTimer:
	;a prescaler is not needed so we use the base clock for the timer
	in  r23, TCCR1B;
  c4:	7e b5       	in	r23, 0x2e	; 46
	ori r23, 0x01;
  c6:	71 60       	ori	r23, 0x01	; 1
	out TCCR1B, r23;
  c8:	7e bd       	out	0x2e, r23	; 46
	;we initialise the timer value to the appropriate start value for 4.1ms delay.
	ldi r21, 0x5F;
  ca:	5f e5       	ldi	r21, 0x5F	; 95
	ldi r22, 0xD8;
  cc:	68 ed       	ldi	r22, 0xD8	; 216
	out TCNT1H, r21;
  ce:	5d bd       	out	0x2d, r21	; 45
	out TCNT1L, r22;
  d0:	6c bd       	out	0x2c, r22	; 44
	;we enable the Overflow interupt
	in  r18, TIMSK;
  d2:	29 b7       	in	r18, 0x39	; 57
	ori r18, 0x04;
  d4:	24 60       	ori	r18, 0x04	; 4
	out TIMSK, r18;
  d6:	29 bf       	out	0x39, r18	; 57
	ret;
  d8:	08 95       	ret

000000da <InitialiseCounter>:

;Subroutine used for the initialisation of the ring counter
InitialiseCounter:
	;we initialise the ring counter
	ldi r20,1
  da:	41 e0       	ldi	r20, 0x01	; 1
	mov r3,r20
  dc:	34 2e       	mov	r3, r20
		
	ret;
  de:	08 95       	ret

000000e0 <InitialiseRT>:

;Subroutine used for the initialisation of the USART
	InitialiseRT:
;set UBRR to 64(the apropriate value for a baud rate of 9600 and a clock of 10MHz)
	ldi r16, 64
  e0:	00 e4       	ldi	r16, 0x40	; 64
	ldi r17, 0 
  e2:	10 e0       	ldi	r17, 0x00	; 0
	out UBRRL, r16 
  e4:	09 b9       	out	0x09, r16	; 9
	out UBRRH, r17 
  e6:	10 bd       	out	0x20, r17	; 32
	;Enable receiver and tranceiver
	ldi r16, 152 ;| (1<<TXCIE)
  e8:	08 e9       	ldi	r16, 0x98	; 152
	out UCSRB, r16 
  ea:	0a b9       	out	0x0a, r16	; 10
	ldi r16, 6
  ec:	06 e0       	ldi	r16, 0x06	; 6
	out UCSRC,r16
  ee:	00 bd       	out	0x20, r16	; 32
	ret;
  f0:	08 95       	ret

000000f2 <TIM1_COMPA>:

	;This interrupt is triggered every 4.1 msec to light the appropriate 7-segment LED.
	TIM1_COMPA:
	mov	ZL,r4		; initialize Z pointer
  f2:	e4 2d       	mov	r30, r4
	mov	ZH,r5
  f4:	f5 2d       	mov	r31, r5
	;we load the first BCD number address from the memory
	ld r18,Z+
  f6:	21 91       	ld	r18, Z+
	; the X register is prepared for the next loop
	mov	r4,ZL		
  f8:	4e 2e       	mov	r4, r30
	mov	r5,ZH
  fa:	5f 2e       	mov	r5, r31
	;we load the address of the 0 represantation of 7 segment LED
	ldi	ZL,p7segmentLedL	 
  fc:	e0 e5       	ldi	r30, 0x50	; 80
	ldi	ZH,p7segmentLedH
  fe:	f4 e0       	ldi	r31, 0x04	; 4
	;we get the address of the needed number represented in 7 segment LED
	add ZL,r18
 100:	e2 0f       	add	r30, r18
	;we load the the represantation from the memory
	ld r18,Z+
 102:	21 91       	ld	r18, Z+
	;we set the interupt flag to zero
	in  r23, TIFR;
 104:	78 b7       	in	r23, 0x38	; 56
	ori r23, 16;
 106:	70 61       	ori	r23, 0x10	; 16
	out TIFR, r23;
 108:	78 bf       	out	0x38, r23	; 56
	;we initialise the screen output
	ldi r21, 0x00;
 10a:	50 e0       	ldi	r21, 0x00	; 0
	out PORTA, r21;
 10c:	5b bb       	out	0x1b, r21	; 27
	;we sent the output of the 7 segment LED and the ring counter
	out PORTC, r3;
 10e:	35 ba       	out	0x15, r3	; 21
	out PORTA, r18;
 110:	2b bb       	out	0x1b, r18	; 27
	;we initialise the timer value to the appropriate start value for 4.1ms delay.
	ldi r21, 0x5F;
 112:	5f e5       	ldi	r21, 0x5F	; 95
	ldi r22, 0xD8;
 114:	68 ed       	ldi	r22, 0xD8	; 216
	out TCNT1H, r21;
 116:	5d bd       	out	0x2d, r21	; 45
	out TCNT1L, r22;
 118:	6c bd       	out	0x2c, r22	; 44
	;we move the ring counter
	lsl r3       ; rotate the value
 11a:	33 0c       	add	r3, r3
	breq initialise;
 11c:	09 f0       	breq	.+2      	; 0x120 <initialise>
	reti; 
 11e:	18 95       	reti

00000120 <initialise>:
	;this block of code is used to reset the process 
	initialise :
	ldi r20,1
 120:	41 e0       	ldi	r20, 0x01	; 1
	mov r3,r20
 122:	34 2e       	mov	r3, r20
	ldi	XL,BCDNumberL	; initialize X pointer
 124:	a2 e6       	ldi	r26, 0x62	; 98
	ldi	XH,BCDNumberH	
 126:	b0 e0       	ldi	r27, 0x00	; 0
	reti;
 128:	18 95       	reti

0000012a <ClearScreen>:


	;This routine is used to set to the memory the character that clears the the screen.
	 ClearScreen:
	ldi	XL,CommandL
 12a:	a0 e6       	ldi	r26, 0x60	; 96
	ldi	XH,CommandH
 12c:	b0 e0       	ldi	r27, 0x00	; 0
	ldi r16,0x0A
 12e:	0a e0       	ldi	r16, 0x0A	; 10
	ldi r17,0x0B
 130:	1b e0       	ldi	r17, 0x0B	; 11

00000132 <loopCl>:
	;subi XL,9 ;NEW CODE
	;this loop is used to 'visit' the memory we utilise
	loopCl:
	st X+,r16
 132:	0d 93       	st	X+, r16
	dec r17
 134:	1a 95       	dec	r17
	cpi r17,0
 136:	10 30       	cpi	r17, 0x00	; 0
	brne loopCl
 138:	e1 f7       	brne	.-8      	; 0x132 <loopCl>
	ret
 13a:	08 95       	ret

0000013c <MoveMemory>:


	;This routine is used to move the stored data by one address.
	;Problem with the code: The first useful byte will be at the second used address.
	MoveMemory:
		ldi	XL,CommandL
 13c:	a0 e6       	ldi	r26, 0x60	; 96
		ldi	XH,CommandH
 13e:	b0 e0       	ldi	r27, 0x00	; 0
		mov r16,XL
 140:	0a 2f       	mov	r16, r26
		dec r16
 142:	0a 95       	dec	r16
		ldi r17,8
 144:	18 e0       	ldi	r17, 0x08	; 8
		add XL,r17
 146:	a1 0f       	add	r26, r17

00000148 <AccessLoop>:
		AccessLoop:
		ld r17,X+
 148:	1d 91       	ld	r17, X+
		st X, r17
 14a:	1c 93       	st	X, r17
		SUBI XL,2
 14c:	a2 50       	subi	r26, 0x02	; 2
		cp XL, r16
 14e:	a0 17       	cp	r26, r16
		brne AccessLoop
 150:	d9 f7       	brne	.-10     	; 0x148 <AccessLoop>
	ret;
 152:	08 95       	ret

00000154 <USART_UDRE>:
	;This routine is used for the  UDRE interrupt and sends the ok signal
	USART_UDRE:
	ldi	ZL,OKL		; initialize Z pointer
 154:	ec e4       	ldi	r30, 0x4C	; 76
	ldi	ZH,OKH
 156:	f4 e0       	ldi	r31, 0x04	; 4

00000158 <puts>:
puts:	
 	ld	r16,Z+				; load character from pmem		
 158:	01 91       	ld	r16, Z+

0000015a <putc>:
  putc:  
 out TCNT2, r16			; replaced 
 15a:	04 bd       	out	0x24, r16	; 36
 cpi	r16,0x0A		; check if null
 15c:	0a 30       	cpi	r16, 0x0A	; 10
; breq	DisableTxc
 rjmp puts
 15e:	fc cf       	rjmp	.-8      	; 0x158 <puts>

00000160 <puts_end>:
 puts_end:
 reti
 160:	18 95       	reti

00000162 <USART_RXC>:

 ;This routine is used to handle the USART_RXC interrupt to read an ascii character from the RS-232.Then it handles the byte with the control routine.
;If we encounter the 0x0a ascii then it starts transmiting the message ok.
 USART_RXC: 
  gets:  
  in r18, UDR 
 162:	2c b1       	in	r18, 0x0c	; 12
  in r18, UDR ; added 
 164:	2c b1       	in	r18, 0x0c	; 12
  mov r18, r15 ; added 
 166:	2f 2d       	mov	r18, r15
  ;st	X+,r18	
  ;cpi	r16,$0A		; check if null
	call Control
 168:	0e 94 ba 00 	call	0x174	; 0x174 <Control>
; breq	EnableTxc
  in r17,UCSRA
 16c:	1b b1       	in	r17, 0x0b	; 11
  sbrs r17, RXC 
 16e:	17 ff       	sbrs	r17, 7

00000170 <gets_end>:
	 gets_end:			; return from subroutine
	 reti
 170:	18 95       	reti
	 rjmp gets			; store character to buffer
 172:	f7 cf       	rjmp	.-18     	; 0x162 <USART_RXC>

00000174 <Control>:

;Subroutine to handle the incoming data. It uses r18 as an argument.
 Control:
		 mov r18,r24
 174:	28 2f       	mov	r18, r24
		cpi r18, 0x30
 176:	20 33       	cpi	r18, 0x30	; 48
		BRSH higher
 178:	18 f4       	brcc	.+6      	; 0x180 <higher>
		
		cpi r18,0x0A
 17a:	2a 30       	cpi	r18, 0x0A	; 10
		breq EnableTxcCall
 17c:	c9 f0       	breq	.+50     	; 0x1b0 <EnableTxcCall>
		ret
 17e:	08 95       	ret

00000180 <higher>:
	higher:
		cpi r18, 0x39
 180:	29 33       	cpi	r18, 0x39	; 57
		BRLO SaveToMemory
 182:	28 f0       	brcs	.+10     	; 0x18e <SaveToMemory>
		cpi r18,0x43
 184:	23 34       	cpi	r18, 0x43	; 67
		breq ClearScreenCall
 186:	59 f0       	breq	.+22     	; 0x19e <ClearScreenCall>
		cpi r18,0x4E
 188:	2e 34       	cpi	r18, 0x4E	; 78
		breq ClearScreenCall
 18a:	49 f0       	breq	.+18     	; 0x19e <ClearScreenCall>
		ret;
 18c:	08 95       	ret

0000018e <SaveToMemory>:

	;Routine that reads an ascii number, finds the corresponding number and stores it to memory 
		SaveToMemory:
	ldi	XL,CommandL
 18e:	a0 e6       	ldi	r26, 0x60	; 96
	ldi	XH,CommandH
 190:	b0 e0       	ldi	r27, 0x00	; 0
	ldi r16,0x30	
 192:	00 e3       	ldi	r16, 0x30	; 48
	sub r18,r16
 194:	20 1b       	sub	r18, r16
	st X,r18
 196:	2c 93       	st	X, r18
	call MoveMemory
 198:	0e 94 9e 00 	call	0x13c	; 0x13c <MoveMemory>
	ret;
 19c:	08 95       	ret

0000019e <ClearScreenCall>:

	;an intermidiate block of code to call the function ClearScreen
	ClearScreenCall:
	call ClearScreen
 19e:	0e 94 95 00 	call	0x12a	; 0x12a <ClearScreen>
		ret;
 1a2:	08 95       	ret

000001a4 <EnableTrasmitCall>:


	EnableTrasmitCall:
	ldi r16, (1<<RXEN) | (1<<TXEN) | (1<<RXCIE) | (1<<UDRIE)
 1a4:	08 eb       	ldi	r16, 0xB8	; 184
	out UCSRB, r16 
 1a6:	0a b9       	out	0x0a, r16	; 10
;	ldi r16, 64
;	out UCSRA, r16 
	ret;
 1a8:	08 95       	ret

000001aa <DisableTransmit>:

DisableTransmit:
	ldi r16, (1<<RXEN) | (1<<TXEN) | (1<<RXCIE) 
 1aa:	08 e9       	ldi	r16, 0x98	; 152
	out UCSRB, r16 
 1ac:	0a b9       	out	0x0a, r16	; 10
	reti;
 1ae:	18 95       	reti

000001b0 <EnableTxcCall>:
	;

EnableTxcCall:
ldi	XL,CommandL	; initialize X pointer
 1b0:	a0 e6       	ldi	r26, 0x60	; 96
ldi	XH,CommandH	; to Command address
 1b2:	b0 e0       	ldi	r27, 0x00	; 0
inc XL
 1b4:	a3 95       	inc	r26
mov r4, XL
 1b6:	4a 2e       	mov	r4, r26
mov r5,XH
 1b8:	5b 2e       	mov	r5, r27
	;call EnableTxc
	ret;
 1ba:	08 95       	ret

Disassembly of section .text.InitialiseRT:

0000033a <InitialiseRT>:

const PROGMEM uint8_t data1[] = {"OK\n"};
//Subroutine used for the initialization of the USART

void InitialiseRT(){
	UBRRL = (uint8_t)(64);
 33a:	80 e4       	ldi	r24, 0x40	; 64
 33c:	89 b9       	out	0x09, r24	; 9
	// write to higher byte
	UBRRH = (uint8_t)(0);
 33e:	10 bc       	out	0x20, r1	; 32
	UCSRB = (uint8_t)(152);
 340:	88 e9       	ldi	r24, 0x98	; 152
 342:	8a b9       	out	0x0a, r24	; 10
	UCSRC = (uint8_t)(6);
 344:	86 e0       	ldi	r24, 0x06	; 6
 346:	80 bd       	out	0x20, r24	; 32
 348:	08 95       	ret

Disassembly of section .text.EnableTxc:

0000034a <EnableTxc>:
	
}
 	//This routine is used to enable the UDR Interrupt.

 void EnableTxc(){
	 UCSRB = (uint8_t)(184);
 34a:	88 eb       	ldi	r24, 0xB8	; 184
 34c:	8a b9       	out	0x0a, r24	; 10
 34e:	08 95       	ret

Disassembly of section .text.DisableTxc:

00000350 <DisableTxc>:
 };
  	//This routine is used to disable the UDR Interrupt.

 void	DisableTxc(){
	 UCSRB = (uint8_t)(152);
 350:	88 e9       	ldi	r24, 0x98	; 152
 352:	8a b9       	out	0x0a, r24	; 10
 354:	08 95       	ret

Disassembly of section .text.USART_UDRE:

000002e8 <USART_UDRE>:
 
 	//This routine is used for the  UDRE interrupt and sends the ok signal

 void USART_UDRE(){
	 int i;
	 for(i=0; i<3;i++ ){
 2e8:	20 e0       	ldi	r18, 0x00	; 0
 2ea:	30 e0       	ldi	r19, 0x00	; 0
 2ec:	0f c0       	rjmp	.+30     	; 0x30c <USART_UDRE+0x24>
		 ;UDR = data1[i];
 2ee:	c9 01       	movw	r24, r18
 2f0:	03 2e       	mov	r0, r19
 2f2:	00 0c       	add	r0, r0
 2f4:	aa 0b       	sbc	r26, r26
 2f6:	80 55       	subi	r24, 0x50	; 80
 2f8:	9f 4f       	sbci	r25, 0xFF	; 255
 2fa:	af 4f       	sbci	r26, 0xFF	; 255
 2fc:	fc 01       	movw	r30, r24
 2fe:	84 91       	lpm	r24, Z
 300:	a7 fd       	sbrc	r26, 7
 302:	80 81       	ld	r24, Z
 304:	8c b9       	out	0x0c, r24	; 12
		 TCNT2= data1[i];
 306:	84 bd       	out	0x24, r24	; 36
 
 	//This routine is used for the  UDRE interrupt and sends the ok signal

 void USART_UDRE(){
	 int i;
	 for(i=0; i<3;i++ ){
 308:	2f 5f       	subi	r18, 0xFF	; 255
 30a:	3f 4f       	sbci	r19, 0xFF	; 255
 30c:	23 30       	cpi	r18, 0x03	; 3
 30e:	31 05       	cpc	r19, r1
 310:	74 f3       	brlt	.-36     	; 0x2ee <USART_UDRE+0x6>
		 ;UDR = data1[i];
		 TCNT2= data1[i];
	 }
	 DisableTxc();
 312:	0e 94 a8 01 	call	0x350	; 0x350 <DisableTxc>
 316:	08 95       	ret

Disassembly of section .text.__vector_12:

00000210 <__vector_12>:
 }
 //This routine is used for the  UDRE interrupt
 ISR(USART_UDRE_vect){
 210:	1f 92       	push	r1
 212:	0f 92       	push	r0
 214:	0f b6       	in	r0, 0x3f	; 63
 216:	0f 92       	push	r0
 218:	11 24       	eor	r1, r1
 21a:	2f 93       	push	r18
 21c:	3f 93       	push	r19
 21e:	4f 93       	push	r20
 220:	5f 93       	push	r21
 222:	6f 93       	push	r22
 224:	7f 93       	push	r23
 226:	8f 93       	push	r24
 228:	9f 93       	push	r25
 22a:	af 93       	push	r26
 22c:	bf 93       	push	r27
 22e:	ef 93       	push	r30
 230:	ff 93       	push	r31
	 USART_UDRE();
 232:	0e 94 74 01 	call	0x2e8	; 0x2e8 <USART_UDRE>
 }
 236:	ff 91       	pop	r31
 238:	ef 91       	pop	r30
 23a:	bf 91       	pop	r27
 23c:	af 91       	pop	r26
 23e:	9f 91       	pop	r25
 240:	8f 91       	pop	r24
 242:	7f 91       	pop	r23
 244:	6f 91       	pop	r22
 246:	5f 91       	pop	r21
 248:	4f 91       	pop	r20
 24a:	3f 91       	pop	r19
 24c:	2f 91       	pop	r18
 24e:	0f 90       	pop	r0
 250:	0f be       	out	0x3f, r0	; 63
 252:	0f 90       	pop	r0
 254:	1f 90       	pop	r1
 256:	18 95       	reti

Disassembly of section .text.USART_RXC:

00000318 <USART_RXC>:
  //This routine is used to handle the USART_RXC interrupt to read an ascii character from the RS-232.Then it handles the byte with the control routine.
  //If we encounter the 0x0a ascii then it starts transmiting the message ok.
 void USART_RXC(){
 318:	cf 93       	push	r28
	 unsigned char temp= TCNT0;
 31a:	c2 b7       	in	r28, 0x32	; 50
	 uint8_t temp2= UDR;
 31c:	8c b1       	in	r24, 0x0c	; 12
	 temp2= UDR;
 31e:	8c b1       	in	r24, 0x0c	; 12

	 Control(temp);
 320:	8c 2f       	mov	r24, r28
 322:	90 e0       	ldi	r25, 0x00	; 0
 324:	0e 94 ba 00 	call	0x174	; 0x174 <Control>
	 if(temp==0x0a){
 328:	ca 30       	cpi	r28, 0x0A	; 10
 32a:	11 f4       	brne	.+4      	; 0x330 <USART_RXC+0x18>
		 EnableTxc();
 32c:	0e 94 a5 01 	call	0x34a	; 0x34a <EnableTxc>
	 }
	 if( UCSRA & (1<<RXC)){
 330:	5f 99       	sbic	0x0b, 7	; 11
		 USART_RXC();
 332:	0e 94 8c 01 	call	0x318	; 0x318 <USART_RXC>
	 }
	 
 }
 336:	cf 91       	pop	r28
 338:	08 95       	ret

Disassembly of section .text.__vector_11:

00000258 <__vector_11>:
   //This routine is used to handle the USART_RXC interrupt
 ISR(USART_RXC_vect)
 {
 258:	1f 92       	push	r1
 25a:	0f 92       	push	r0
 25c:	0f b6       	in	r0, 0x3f	; 63
 25e:	0f 92       	push	r0
 260:	11 24       	eor	r1, r1
 262:	2f 93       	push	r18
 264:	3f 93       	push	r19
 266:	4f 93       	push	r20
 268:	5f 93       	push	r21
 26a:	6f 93       	push	r22
 26c:	7f 93       	push	r23
 26e:	8f 93       	push	r24
 270:	9f 93       	push	r25
 272:	af 93       	push	r26
 274:	bf 93       	push	r27
 276:	ef 93       	push	r30
 278:	ff 93       	push	r31
	 USART_RXC();
 27a:	0e 94 8c 01 	call	0x318	; 0x318 <USART_RXC>
 }
 27e:	ff 91       	pop	r31
 280:	ef 91       	pop	r30
 282:	bf 91       	pop	r27
 284:	af 91       	pop	r26
 286:	9f 91       	pop	r25
 288:	8f 91       	pop	r24
 28a:	7f 91       	pop	r23
 28c:	6f 91       	pop	r22
 28e:	5f 91       	pop	r21
 290:	4f 91       	pop	r20
 292:	3f 91       	pop	r19
 294:	2f 91       	pop	r18
 296:	0f 90       	pop	r0
 298:	0f be       	out	0x3f, r0	; 63
 29a:	0f 90       	pop	r0
 29c:	1f 90       	pop	r1
 29e:	18 95       	reti

Disassembly of section .text.main:

000001bc <main>:
 




int main(void){ 
 1bc:	cf 93       	push	r28
 1be:	df 93       	push	r29
 1c0:	cd b7       	in	r28, 0x3d	; 61
 1c2:	de b7       	in	r29, 0x3e	; 62
 1c4:	2c 97       	sbiw	r28, 0x0c	; 12
 1c6:	0f b6       	in	r0, 0x3f	; 63
 1c8:	f8 94       	cli
 1ca:	de bf       	out	0x3e, r29	; 62
 1cc:	0f be       	out	0x3f, r0	; 63
 1ce:	cd bf       	out	0x3d, r28	; 61
	
	
	 
	
	
	PROGMEM uint8_t data2[] = {192,249,164,176,153,146,130,184,128,144,255,255};
 1d0:	8c e0       	ldi	r24, 0x0C	; 12
 1d2:	e0 e6       	ldi	r30, 0x60	; 96
 1d4:	f0 e0       	ldi	r31, 0x00	; 0
 1d6:	de 01       	movw	r26, r28
 1d8:	11 96       	adiw	r26, 0x01	; 1
 1da:	01 90       	ld	r0, Z+
 1dc:	0d 92       	st	X+, r0
 1de:	8a 95       	dec	r24
 1e0:	e1 f7       	brne	.-8      	; 0x1da <main+0x1e>
	
	InitialiseMemory();
 1e2:	0e 94 5a 00 	call	0xb4	; 0xb4 <InitialiseMemory>
        ClearScreen(data1);
 1e6:	80 eb       	ldi	r24, 0xB0	; 176
 1e8:	90 e0       	ldi	r25, 0x00	; 0
 1ea:	a0 e0       	ldi	r26, 0x00	; 0
 1ec:	0e 94 95 00 	call	0x12a	; 0x12a <ClearScreen>
		ClearScreen(data2);
 1f0:	ce 01       	movw	r24, r28
 1f2:	01 96       	adiw	r24, 0x01	; 1
 1f4:	0e 94 95 00 	call	0x12a	; 0x12a <ClearScreen>
		InitialiseLED();
 1f8:	0e 94 5d 00 	call	0xba	; 0xba <InitialiseLED>
			InitialiseCounter();
 1fc:	0e 94 6d 00 	call	0xda	; 0xda <InitialiseCounter>
			InitialiseRT();			
 200:	0e 94 9d 01 	call	0x33a	; 0x33a <InitialiseRT>
		 InitialiseTimer();
 204:	0e 94 62 00 	call	0xc4	; 0xc4 <InitialiseTimer>
		 InitialiseMemory();
 208:	0e 94 5a 00 	call	0xb4	; 0xb4 <InitialiseMemory>
		sei();
 20c:	78 94       	sei
 20e:	ff cf       	rjmp	.-2      	; 0x20e <__EEPROM_REGION_LENGTH__+0xe>

Disassembly of section .text.__vector_8:

000002a0 <__vector_8>:
    }
}
//This interrupt is triggered every 4.1 msec to light the appropriate 7-segment LED.

ISR(TIMER1_OVF_vect)
{
 2a0:	1f 92       	push	r1
 2a2:	0f 92       	push	r0
 2a4:	0f b6       	in	r0, 0x3f	; 63
 2a6:	0f 92       	push	r0
 2a8:	11 24       	eor	r1, r1
 2aa:	2f 93       	push	r18
 2ac:	3f 93       	push	r19
 2ae:	4f 93       	push	r20
 2b0:	5f 93       	push	r21
 2b2:	6f 93       	push	r22
 2b4:	7f 93       	push	r23
 2b6:	8f 93       	push	r24
 2b8:	9f 93       	push	r25
 2ba:	af 93       	push	r26
 2bc:	bf 93       	push	r27
 2be:	ef 93       	push	r30
 2c0:	ff 93       	push	r31
	TIM1_COMPA();
 2c2:	0e 94 79 00 	call	0xf2	; 0xf2 <TIM1_COMPA>
}
 2c6:	ff 91       	pop	r31
 2c8:	ef 91       	pop	r30
 2ca:	bf 91       	pop	r27
 2cc:	af 91       	pop	r26
 2ce:	9f 91       	pop	r25
 2d0:	8f 91       	pop	r24
 2d2:	7f 91       	pop	r23
 2d4:	6f 91       	pop	r22
 2d6:	5f 91       	pop	r21
 2d8:	4f 91       	pop	r20
 2da:	3f 91       	pop	r19
 2dc:	2f 91       	pop	r18
 2de:	0f 90       	pop	r0
 2e0:	0f be       	out	0x3f, r0	; 63
 2e2:	0f 90       	pop	r0
 2e4:	1f 90       	pop	r1
 2e6:	18 95       	reti
